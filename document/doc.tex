\documentclass[a4paper,francais]{insalyon}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}

\usepackage{subfig}
\usepackage{graphicx, multicol}
\graphicspath{{fig/}}

\usepackage{amssymb}
\usepackage{amsthm}

\usepackage{hyperref}

\newcommand{\cad}{c.-à-d.}

\title{ELP}
\author{Tristan Roussillon}

\begin{document}

\maketitle

L'objectif de ce document est de présenter d'une façon simple dix thèmes centraux autour desquels se déroule l'activité de programmation. L'étudiant les découvre en général à l'occasion d'un projet ou d'un exercice et par le prisme d'un langage particulier. Il s'agit ici de les mettre en mots afin de l'aider à nommer et prendre conscience de ces éléments importants. 

\section{Les fondamentaux de l'informatique et la programmation}

L'informatique est une science dont l'objet d'étude est constitué de grands piliers : représentation de l'information, algorithme, language et machine \cite{rapportacscience} : 
%% \footnote{cf. le rapport de l'académie des sciences:
%%   \href{https://www.academie-sciences.fr/pdf/rapport/rads\_0513.pdf}
%%   {l'enseignement de l'informatique en France, il est urgent de ne plus attendre, mai 2013}.
%%   }.
\begin{description}
\item[information] (Larousse) Élément de connaissance susceptible d'être représenté à l'aide de conventions pour être conservé, traité ou communiqué. 
\item[algorithme] (\cite[p.4]{knuth}) Ensemble fini de règles qui fourni une séquence d'opérations. Ces opérations permettent d'obtenir, à partir de zéro ou plusieurs informations en entrée, au moins une information en sortie, qui est la réponse à un problème spécifique. Un algorithme doit de plus être précisément défini, sans ambiguité sur les actions à mener, et effectivement réalisable, dans le sens où l'exécution doit terminer après un nombre fini d'étapes, chaque étape étant suffisamment élémentaire pour pouvoir, en principe, être effectuée exactement, en un temps fini, par un opérateur humain.
  %Synonyme de recette, méthode, technique, procédure, 
\item[langage] Dans ce contexte, on appelle \emph{langage} un système de signe capable d'exprimer un algorithme. Il est doté d'une \emph{syntaxe} (en fonction des règles de sa \emph{grammaire}, certains agencements de signe sont admissibles et d'autres non) et d'une \emph{sémantique} (tous les agencements de signe admissibles ont une signification précise). Tous les langages n'ont pas le même pouvoir expressif ; seuls ceux dits complets au sens de Turing sont capables d'exprimer n'importe quel algorithme.  
\item[machine] Dans ce contexte, on appelle \emph{machine} tout dispositif capable de traduire un algorithme, exprimé dans un langage spécifique, en actions. L'orgue de barbarie, le métier à tisser Jacquart, l'ordinateur, le smartphone sont des exemples de machine. 
\end{description}

La programmation consiste à écrire des programmes, {\cad} exprimer des algorithmes dans un langage spécifique, afin d'adapter les actions exécutées par une machine. Elle est au c\oe ur de l'informatique. Du fait de l'omniprésence de l'informatique dans de nombreux domaines de l'activité humaine, elle est pratiquée par de nombreux ingénieurs. 

%https://fr.wikipedia.org/wiki/Langage
%https://fr.wikipedia.org/wiki/Langage_informatique
%https://fr.wikipedia.org/wiki/Langage_de_programmation
%https://fr.wikipedia.org/wiki/Langage_formel

\section{Compilation, exécution}

En informatique, dans son acception large, la compilation consiste en la traduction d'un programme écrit dans un langage, en un programme écrit dans un autre langage. Par exemple, j'ai rédigé ce que vous lisez en {\LaTeX} et j'ai utilisé l'outil \texttt{pdflatex} pour produire ce fichier \texttt{pdf} : \texttt{pdflatex document.tex} $\leadsto$ \texttt{document.pdf}
\footnote{Tous les exemples donnés dans ce document supposent un environnement Linux.}.  

Au sens strict, le produit de la compilation est un fichier binaire directement exécutable par l'ordinateur, voire un programme écrit dans un langage intermédiaire pouvant être exécuté par une machine virtuelle, {\cad} un logiciel émulant les fonctionnalités d'un ordinateur. Le \emph{compilateur} est le logiciel qui effectue une telle traduction. Ce traitement est habituellement terminé avant toute exécution du programme obtenu.

Dans d'autres cas, le programme source est analysé, traduit et exécuté petit à petit par un logiciel appelé \emph{interpréteur}.

Pour synthétiser, on peut retenir ceci :
\begin{description}
\item[compilé] ~\\ compilateur(programme source) $\leadsto$ fichier exécutable ; \\
  système d'exploitation(fichier exécutable) $\leadsto$ actions
\item[semi-compilé] ~\\ compilateur(programme source) $\leadsto$ programme intermédiaire ; \\
  machine virtuelle(programme intermédiaire) $\leadsto$ actions
\item[interprété] ~\\ interpréteur(programme source) $\leadsto$ actions
\end{description}

Même si un langage peut en théorie être aussi bien compilé ou interprété, il apparaît dans les faits avec une certaine implémentation. Voici quelques exemples.

\subsection{Exemples de programmes compilés}

Les programmes écrits en Haskell, Go, C peuvent être compilés respectivement avec les compilateurs ghc, golang-go, gcc.
Dans les exemples suivants, la commande de compilation, à laquelle on indique éventuellement le nom du programme source, est à gauche,
le nom du fichier exécutable produit est à droite :
\begin{itemize}
  \item \verb! ghc main.ghc ! $\leadsto$ \texttt{main}
  \item \verb! go build ! $\leadsto$ \texttt{hello}
    \footnote{ Le programme source, appelé obligatoirement \texttt{main.go}, se trouve dans un dossier appelé \texttt{hello} (nom donné au projet dans cet exemple ; le fichier exécutable prend le nom du projet), lui-même contenu dans un dossier \texttt{src} (car l'environnement Go suppose que tous les projets se trouvent dans un dossier appelé \texttt{src}. La commande de compilation \texttt{go build} est exécutée à la racine du projet, {\cad} dans le dossier \texttt{hello/src}. On voit ici qu'il y a toujours de nombreuses \emph{conventions} à connaître. }
  \item \verb! gcc main.c ! $\leadsto$ \texttt{a.out}
\end{itemize}

Les fichiers produits sont directement exécutables depuis le shell : 
\begin{itemize}
\item \verb! ./main ! $\leadsto$ actions
\item \verb! ./hello ! $\leadsto$ actions
\item \verb! ./a.out ! $\leadsto$ actions
\end{itemize}

Ces fichiers contiennent du \emph{code natif}, {\cad} un programme écrit dans un langage machine spécifique à l'environnement utilisé, à la fois en terme de système d'exploitation et d'architecture d'ordinateur. Un code natif est exécuté très rapidemment, mais ne pourra pas être exécuté sur une machine aux caractéristiques différentes de celle sur laquelle le code natif a été produit. 

\subsection{Exemple de programme semi-compilé}

Les programmes écrits en Java sont généralement compilés dans un premier en temps en \emph{byte code} par la commande \texttt{javac} :

\verb! javac Classe.java ! $\leadsto$ \texttt{Classe.class}

Dans un second temps, le \emph{byte code} est éxécuté par la machine virtuelle java, dont l'exécution est lancée par la commande \texttt{java} :

\verb! java Classe ! $\leadsto$ actions \footnote{On fournit à la commande \texttt{java} le nom complet de la classe et la machine virtuelle java charge en mémoire le byte code correspondant, contenu dans le fichier d'extension \texttt{.class}. }

C'est un compromis entre
\emph{portabilité} (le byte code produit peut être exécuté dans n'importe quel environnement pourvu qu'il y ait une machine virtuelle java\footnote{C'est ce qu'exprime le slogan ``Write once, run everywhere''.})
et \emph{rapidité d'exécution} (le byte code est suffisamment proche d'un code natif pour être exécuté relativement rapidement, d'autant que les machines virtuelles sont maintenant dotées de mécanisme de compilation à la volée pour traduire les parties du byte code les plus sollicitées en code natif).   

\subsection{Exemple de programme interprété}

\texttt{Node.js} est un interpréteur de programmes écrits en JavaScript :

\verb! node toto.js ! $\leadsto$ exécute ce qui est écrit dans le fichier \texttt{toto.js}

Les programmes interprétés sont généralement appelés \emph{scripts}. Leur exécution est plus lente, puisque l'analyse du script est effectuée au cours de l'exécution. En revanche, il est généralement possible d'exécuter des scripts incomplets, ce qui facilite leur incorporation dans d'autres contextes (HTML + JavaScript interprétés par un navigateur web par exemple). Cette souplesse accélère aussi le développement de prototypes d'application.


\section{Données}

%donnée une donnée est la représentation d'une information dans un programme : soit dans le texte du programme (code source), soit en mémoire durant l'exécution.
%https://fr.wikipedia.org/wiki/Donn%C3%A9e_(informatique)
Une \emph{valeur} est une donnée, {\cad} la représentation d'une information, aussi bien dans le texte du programme source, qu'en mémoire durant l'exécution. 
Un \emph{littéral} est une valeur écrite explicitement dans le programme source, comme 2, 5.7, True, "Alice" ou encore
\begin{verbatim}
{ "estExplicite" : true, "estStatique" : true }.
\end{verbatim}
\'Evidemment, un programme ne contenant que des valeurs littérales ne serait pas très intéressant, car il ne serait pas capable d'adapter les actions de la machine en fonction d'informations données. Ce qui rend intéressant les programmes sont leurs variables. 
Une \emph{variable} représente une donnée susceptible de changer au cours de l'exécution ou d'une exécution à l'autre. Elle possède un nom, appelé aussi \emph{identifiant}, une \emph{valeur} stockée en mémoire au cours de l'exécution (et qui peut changer ou non), ainsi qu'un \emph{type} caractérisant les valeurs admissibles et les opérations pouvant leur être appliquées. Les variables ont également une durée de vie, appelée aussi \emph{portée}, en général limitée (pour ne pas conserver en mémoire une valeur qui serait devenue inutile).  
%compliqué à précisé. 
%qui peut être restreinte qui est le bloc, {\cad} la portion de programme bien délimitée, dans laquelle elle est déclarée ou utilisée pour la première fois.

Comme sur la \textsc{Figure}~\ref{fig:var}, la métaphore de la boite est largement utilisée en programmation. Une variable est considérée comme une boite bien identifiée, dans laquelle se trouve une (et une seule) valeur. Grâce au typage, la boite est dimensionnée aux valeurs susceptibles d'y être contenue. La plupart du temps, il est possible de remplacer la valeur qui se trouve dans une boite, par une autre : c'est \emph{l'affectation}. Il est aussi possible de ne pas fournir de valeur initiale à la création de la boite ; dans ce cas, elle n'est pas vide, mais contient une valeur arbitraire. Dans certains cas, parce qu'on le spécifie explicitement ou que c'est l'un des principes du langage, comme en Haskell, il est interdit de changer la valeur d'une variable.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=5cm,page=1]{variable} \hspace{1cm}
  \includegraphics[width=5cm,page=2]{variable}
  \caption{Représentation schématique d'une variable.}
  \label{fig:var}
\end{figure}

\subsection{Types de base}

La plupart des langages offrent plusieurs types prédéfinis pour des valeurs élémentaires :
\begin{itemize}
\item le type booléen pour les valeurs de vérité vrai et faux, sur lesquelles agissent au moins les opérateurs booléens (\verb!negation, et, ou,! \ldots),
\item le type entier pour les nombres entiers, signé ou non, pouvant être codés sur 8, 16, 32 ou 64 bits et sur lesquels agissent au moins les opérateurs arithmétiques (\verb!+, -, *, modulo,! \ldots), 
\item le type réel pour des nombres décimaux, codés sur 32 ou 64 bits selon la représentation en virgule flottante de la \href{https://fr.wikipedia.org/wiki/IEEE_754}{norme IEEE 754}\footnote{A ce propos, \cite{goldberg91} est une lecture encore intéressante.} et sur lesquels agissent aussi des opérateurs arithmétiques (\verb!+, -, *, /,! \ldots),
\item le type caractère selon le standard \href{https://fr.wikipedia.org/wiki/American_Standard_Code_for_Information_Interchange}{ASCII} ou \href{https://fr.wikipedia.org/wiki/Unicode}{Unicode}, sur lequel agissent par exemple des opérateurs de comparaison (\verb!egalite, <, >,! \ldots).
\end{itemize}

\subsection{Types composés}

La plupart des langages de programmation proposent également des types composés, pouvant être paramétrés ou personnalisés, pour des valeurs structurées :
\begin{itemize}
\item Les types \emph{tableau} et \emph{liste}, sont paramétrés par un type \texttt{t} et acceptent une séquence de valeurs du même type \texttt{t} (\texttt{t} est arbitraire, avec parfois des restrictions). L'opérateur d'accès à une valeur de la séquence est souvent noté par des crochets : \verb! unTableau[3] ! retourne la valeur de rang 3 dans la séquence. Les valeurs sont stockées en mémoire les unes à côtés des autres dans le cas des tableaux, tandis qu'elles peuvent être dispersées dans le cas des listes (\textsc{Figure}~\ref{fig:types}(a) et (b)). Cela à un impact sur la rapidité des traitements : l'accès est garanti en un nombre constant d'opérations élémentaires dans le cas des tableaux, alors qu'il peut nécessiter la visite de toutes les valeurs, l'une après l'autre, dans le cas d'une liste, ce qui implique un nombre d'opérations élémentaires proportionnel à la taille de la liste.
\item Il existe aussi des types composés non homogènes qui acceptent une collection de valeurs, appelées \emph{champs}, de types possiblement différents les uns des autres (\textsc{Figure}~\ref{fig:types}(c)). Ils sont généralement appelés \emph{tuple} quand les champs ne sont pas nommés (Haskell, Python), \emph{struct} quand ils le sont (C, Go). L'appelation \emph{type produit} aussi utilisée en Haskell vient de ce que l'ensemble des valeurs admises par un tel type est égal au produit cartésien des ensembles de valeurs représentés par les types des champs. Par exemple, le type \texttt{Typage}, défini en Go par 
\begin{verbatim}
type Typage struct {
    estExplicite bool
    estStatique bool
}
\end{verbatim}
et en Haskell par l'une de ces deux lignes
\begin{verbatim}
data Typage = CtorTypage Bool Bool --def type produit
type Typage = (Bool, Bool)         --synonyme de tuple
\end{verbatim}
représente le produit cartésien $\{True, False\}$ (pour le premier champs) $\times$ $\{True, False\}$ (pour le second), soit $\{ (True, True), (True, False), (False, True), (False, False) \}$\footnote{J'ai volontairement choisi deux champs de type booléen pour aisément énumérer l'ensemble des valeurs possibles du type produit, mais le principe est le même pour un nombre arbitraire de champs de type différent. Il est par exemple tout à fait possible d'avoir un premier champs de type entier, un deuxième de type caractère, voire un troisième de type liste, \ldots}   
\item Les \emph{classes}, (en Java par exemple, mais plus généralement en programmation orientée-objet), représentent aussi une collection de \emph{champs} (comme des \emph{struct}), mais possiblement enrichies des fonctions, appelés dans ce contexte \emph{méthodes}, qui agissent sur cette collection. Les concepts de fonction et méthode sont revues dans la section~\ref{sec:fonction}.
\item Les \emph{types algébriques}, en référence aux structures algébriques mathématiques, sont des unions disjointes de types produits. Une présentation détaillée des types algébriques en Haskell se trouve par exemple dans \cite[chapitre 3]{haskell}.    
\end{itemize}

\captionsetup[subfigure]{labelformat=empty}
\begin{figure}[htbp]
  \centering
  \parbox[b]{7cm}{
    \subfloat[(a)]{\includegraphics[width=7cm]{tableau}} \\
    \subfloat[(c)]{\includegraphics[width=5cm]{struct}} 
  }
  \parbox[b]{7cm}{
    \subfloat[(b)]{\includegraphics[width=7cm]{liste}}
  }
  \caption{Représentation schématique de valeurs structurées de type homogène en (a) et (b), non homogène en (c).}  
  \label{fig:types}
\end{figure}

%% La plupart des langages offrent également la possibilité au programmeur de définir un type, dit \emph{énuméré}, en donnant explicitement toutes les valeurs possibles (en général automatiquement mises en correspondance avec des entiers). Le type \texttt{JourDeLaSemaine}, par exemple, pourrait être défini comme n'acceptant que les valeurs \verb!Lundi, Mardi,! \ldots \verb!, Dimanche!.

%% En Haskell, par exemple, une fonction est une valeur comme une autre et un type lui est associé. TODO dans fonction ? 

\subsection{Pointeurs}

Enfin, certains langages de bas niveau, comme C ou Go, donnent la possibilité à un programme de manipuler finement la mémoire, par l'intermédiaire de \emph{pointeurs}, {\cad} de variables stockant l'adresse d'un octet en mémoire. Même si cette adresse est un entier, son utilisation particulière est facilitée par l'introduction d'un type spécifique. Le type pointeur est paramétré par un type \texttt{t} correspondant au type de la valeur localisée en mémoire à l'adresse contenue dans le pointeur. La connaissance du type \texttt{t} ne sert pas à dimensionner la boite du pointeur, qui contient une adresse codée sur 32 ou 64 bits selon l'architecture de l'ordinateur, mais sert à lire la valeur, se trouvant à l'adresse mémorisée, ou à lire d'autres valeurs adjacentes, en prenant en compte le nombre d'octets sur lesquels sont stockées ces valeurs. Un pointeur est créé à partir d'une adresse renvoyée par une fonction d'allocation mémoire ou par \emph{l'opérateur d'adresse}, souvent noté \verb!&!. L'accès à la valeur mémorisée à l'adresse contenue dans un pointeur est effectué à l'aide de \emph{l'opérateur de déréférencement}, souvent noté \verb!*!. Les variables de ce court extrait de code Go sont représentées dans la \textsc{Figure}~\ref{fig:pointeur}.  
\begin{verbatim}
x := 2            //var x de type entier contient 2
ptr := &x         //var ptr contient l'adresse de x
fmt.Println(*ptr) //affiche 2 : valeur de x par ptr 
\end{verbatim}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=7cm]{pointeur}
  \caption{Représentation schématique d'un pointeur.}  
  \label{fig:pointeur}
\end{figure}

Dans les langages qui les proposent, comme en C ou Go, les pointeurs sont incontournables, aussi bien pour définir et manipuler des types composés (tableau, listes, struct, arbre, graphe, etc.), qu'à d'autres niveaux, comme celui du passage de paramètres à l'appel d'une fonction (cf. section~\ref{sec:fonction}). Ce qui en fait un concept essentiel, c'est que les pointeurs sont aussi au c\oe{}ur de nombreux algorithmes et présents dans l'implémentation de nombreux autres langages qui ne permettent pourtant pas de les utiliser directement\footnote{Vous lirez certainement un message contenant \texttt{NullPointerException} en exécutant un de vos programmes Java.}.


\subsection{Typage}

Le \emph{typage} consiste à faire correspondre un type à une variable. Il peut être \emph{explicite} (le typage doit être impérativement donné dans le programme) ou \emph{implicite} (le typage n'est pas obligatoirement requis et les types possibles sont déduits automatiquement lors de la compilation ou de l'exécution). Il peut être \emph{statique} (quand le typage est établi et vérifié à la compilation) ou \emph{dynamique} (quand le typage peut être établi au cours de l'exécution). Enfin, la force du typage fait référence à la sévérité du langage quant à la combinaison de valeurs de différents types, mais cette notion est floue et il n'y a pas de définition communément admise de ce qu'est un typage fort ou faible. La \textsc{Table}~\ref{tab:typage} positionne quelques langages par rapport au typage. 
%Même si on peut dire que Haskell est fortement typé au sens où il n'y a aucune conversion implicite de type possible, alors que Javascript est faiblement typé au sens où un tout opérateur renvoie un résultat, quitte à modifier le type de l'un des opérandes.    

\begin{table}[htbp]
  \centering
\begin{tabular}{c|c|c}
  ~ & explicite & implicite \\ \hline 
  statique & C, Java & Haskell, Go \\ \hline
  dynamique & ~ & Javascript, Python
\end{tabular}
\caption{Typage de quelques langages.}
\label{tab:typage}
\end{table}


\section{Fonction}
\label{sec:fonction}

Une \emph{routine} représente un sous-programme qui, à partir d'informations données, effectue un traitement spécifique, relativement indépendant du reste du programme dans lequel il peut être réutilisé plusieurs fois. Les routines permettent de décomposer un programme en parties plus faciles à écrire, modifier, tester, réutiliser. Parmi les routines, on distingue historiquement la \emph{procédure} qui déclenche une action mais ne retourne aucune valeur, de la \emph{fonction}, qui retourne une valeur et, éventuellement, réalise une opération. On emploiera ci-dessous indifférement le mot "fonction", comme c'est le cas dans de nombreux langages.    

Une fonction possède non-seulement un sous-programme, appelé \emph{corps}, mais aussi une \emph{signature}, composée d'au moins un nom et de la liste des \emph{paramètres}, {\cad} les variables dont les valeurs devront être transmises au sous-programme. A cela, s'ajoute éventuellement un type, correspondant généralement au type de la valeur de retour. 

TODO exemple

- passage de paramètre

- fonction, méthode=fonction avec contexte/fonction avec application partielle

- dans certains langages comme Haskell, une fonction est une valeur comme une autre


\section{\'Evaluation des expressions, structures de contrôle}

%expression, évaluation (paresseuse), effets vs pureté, structures de contrôle


Une \emph{expression} est un agencement de signe syntaxiquement correct (littéraux, variables, opérateurs, fonctions)
\begin{itemize}
\item qui produit éventuellement une action, qu'on appelle \emph{effet}, comme le changement de la valeur de variables en mémoire ou une opération d'entrée-sortie, 
\item et qui est \emph{évalué} en une valeur. 
\end{itemize}
Le terme \emph{instruction} est généralement employé dans le cas où le résultat est ignoré et seul l'effet compte.
Voici des exemples d'expression. 

\verb! (i >= 0) && (i < 10) !, \verb! c = pgcd(a,b) !, \verb! print("hello") !

%% \subsection{Interpréteur intéractif}
%% Un \emph{REPL} (pour \emph{Read-Eval-Print Loop}) est un interpréteur intéractif dans lequel l'utilisateur est invité à taper une expression (\emph{Read}). Quand celle-ci est écrite, elle est évaluée (\emph{Eval}) en un résultat, qui est ensuite affiché à l'écran (\emph{Print}), avant que l'utilisateur soit de nouveau invité à taper une expression (\emph{Loop}). C'est très pratique pour jouer avec un langage ou inspecter ce que fait certaines parties d'un programme. 


Il existe quelques langages, dont Haskell, dits \emph{purs}, {\cad} pour lesquels il n'y a pas d'effets (ou plutôt, ils interviennent de manière restreinte et de telle sorte qu'ils ne remettent pas fondamentalement en cause la pureté du langage). Dans ces langages, une expression donnée est toujours évaluée en une et une seule valeur, sans aucun autre effet. C'est un avantage indéniable pour comprendre, à sa simple lecture, ce que fait une partie isolée d'un programme. En revanche, les effets sont pratiques et souvent nécessaires pour atteindre une complexité algorithmique optimale, ce qui explique qu'ils sont admis et exploités par la majorité des langages de programmation.    

Cependant, la pureté offre un autre avantage. En effet, elle rend possible \emph{l'évaluation paresseuse} \cite[Lecture 6: Lazy Evaluation]{coursHaskell}, qui désigne une stratégie d'évaluation des expressions dans laquelle l'évaluation est repoussée aussi longtemps que possible. Les expressions ne sont pas évaluées tant qu'il n'est pas absolument nécessaire de le faire. Les expressions sont conservées en mémoire sous forme symbolique sans autre traitement. Par exemple, supposons que nous ayons défini en Haskell la fonction \texttt{f} telle que \verb! f x y = x + 2 !, ce qui signifie que \texttt{f} retourne la valeur de son premier paramètre augmentée de 2 (et ignore le second). L'évaluation paresseuse de l'expression \verb! f 5 (29^35792) ! n'implique pas l'évaluation de l'expression \verb! (29^35792) ! qui sera simplement stockée en mémoire sans aucun calcul et \texttt{f} sera appelée immédiatement. Puisque \texttt{f} retourne \texttt{5} sans utiliser le second argument, l'expression \verb! (29^35792) ! sera finalement supprimée sans avoir été évaluée. Au contraire, dans un langage à \emph{évaluation stricte}, évaluer \verb! f 5 (29^35792) ! exige l'évaluation de \texttt{5} (immédiate) et \verb! 29^35792 ! (ce qui nécessite un calcul coûteux) avant de passer les résultats à \texttt{f}. Dans cet exemple, le calcul coûteux s'avère finalement inutile. Mais l'avantage de l'évaluation stricte, c'est de pouvoir prédire exactement dans quel ordre les traitements se feront, ce qui est crucial quand les expressions ont des effets. C'est pourquoi l'évaluation paresseuse n'est possible qu'en l'absence d'effet.

Enfin, l'évaluation paresseuse permet de définir des \emph{structures de contrôle} comme de simples fonctions. Par exemple, la structure de contrôle \texttt{if} évalue ou exécute, parmi deux alternatives, seulement l'une d'elles, selon la valeur d'une condition. En Haskell, l'évaluation paresseuse permet de définir cette structure de contrôle à l'aide d'une simple fonction. La fonction \texttt{if} est définie de telle sorte que pour évaluer \verb! if condition a b !, seulement l'expression \texttt{a} est évaluée si \texttt{condition} est évaluée à vrai, tandis que l'expression \texttt{b} n'est pas utilisée, et inversement si \texttt{condition} est évaluée à faux. Au contraire, dans les langages à évaluation stricte, tous les arguments d'une telle fonction seraient évalués, ce qui serait absurde. C'est pourquoi, il existe dans ces langages des constructions spécifiques pour les structures de contrôle qui fonctionnent et sont nommées à peu près toujours de la même manière :
\begin{description}
\item[branchement] \verb! if / then / else / elif !, \verb! switch / case / break !, 
\item[boucle] \verb! for / break / continue !, \verb! while !, \verb! do while !.
\end{description}

\section{Polymorphisme}

- polymorphisme (interface/héritage, classe de type)

\section{Organisation du code source et conflits de nom}

A FAIRE

\section{Erreurs et exceptions}

A FAIRE

\section{Parallélisme et concurrence}

A FAIRE

\section{Paradigmes de programmation}

- impératif, (CRO)
- fonctionnel, 
- objet, 
- concurrent, (PPC)

\bibliographystyle{plain}
\bibliography{refs}

\end{document}


