\documentclass[a4paper,francais]{insalyon}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}

\usepackage{graphicx}
\graphicspath{{fig/}}

\usepackage{amssymb}
\usepackage{amsthm}

\usepackage{hyperref}

\newcommand{\cad}{c.-à-d.}

\title{ELP}
\author{Tristan Roussillon}

\begin{document}

\maketitle

L'objectif de ce document est de présenter d'une façon simple dix thèmes centraux autour desquels se déroule l'activité de programmation. L'étudiant les découvre en général à l'occasion d'un exercice et par le prisme d'un langage particulier. Il s'agit ici de les mettre en mots afin d'accompagner l'étudiant dans son apprentissage et l'aider à prendre du recul sur ces éléments importants. 

\section{La programmation et les fondamentaux de l'informatique}

L'informatique est une science dont l'objet d'étude est constitué de grands piliers : représentation de l'information, algorithme, language et machine \cite{rapportacscience} : 
%% \footnote{cf. le rapport de l'académie des sciences:
%%   \href{https://www.academie-sciences.fr/pdf/rapport/rads\_0513.pdf}
%%   {l'enseignement de l'informatique en France, il est urgent de ne plus attendre, mai 2013}.
%%   }.
\begin{description}
\item[information] (Larousse) Élément de connaissance susceptible d'être représenté à l'aide de conventions pour être conservé, traité ou communiqué. 
\item[algorithme] (\cite[p.4]{knuth}) Ensemble fini de règles qui fourni une séquence d'opérations. Ces opérations permettent d'obtenir, à partir de zéro ou plusieurs informations en entrée, au moins une information en sortie, qui est la réponse à un problème spécifique. Un algorithme doit de plus être précisément défini, sans ambiguité sur les actions à mener, et effectivement réalisable, dans le sens où l'exécution doit terminer après un nombre fini d'étapes, chaque étape étant suffisamment élémentaire pour pouvoir, en principe, être effectuée exactement, en un temps fini, par un opérateur humain.
  %Synonyme de recette, méthode, technique, procédure, 
\item[langage] Dans ce contexte, on appelle \emph{langage} un système de signe capable d'exprimer un algorithme. Il est doté d'une \emph{syntaxe} (en fonction des règles de sa \emph{grammaire}, certains agencements de signe sont admissibles et d'autres non) et d'une \emph{sémantique} (tous les agencements de signe admissibles ont une signification précise). Tous les langages n'ont pas le même pouvoir expressif ; seuls ceux dits complets au sens de Turing sont capables d'exprimer n'importe quel algorithme.  
\item[machine] Dans ce contexte, on appelle \emph{machine} tout dispositif capable de traduire un algorithme, exprimé dans un langage spécifique, en actions. L'orgue de barbarie, le métier à tisser Jacquart, l'ordinateur, le smartphone sont des exemples de machine. 
\end{description}

La programmation consiste à écrire des programmes, {\cad} exprimer des algorithmes dans un langage spécifique, afin d'adapter les actions exécutées par une machine. Elle est au c\oe ur de l'informatique. Du fait de l'omniprésence de l'informatique dans de nombreux domaines de l'activité humaine, elle est pratiquée par de nombreux ingénieurs. 

%https://fr.wikipedia.org/wiki/Langage
%https://fr.wikipedia.org/wiki/Langage_informatique
%https://fr.wikipedia.org/wiki/Langage_de_programmation
%https://fr.wikipedia.org/wiki/Langage_formel

\section{Compilation, exécution}

En informatique, dans son acception large, la compilation consiste en la traduction d'un programme écrit dans un langage, en un programme écrit dans un autre langage. Par exemple, j'ai rédigé ce que vous lisez en {\LaTeX} et j'ai utilisé l'outil \texttt{pdflatex} pour produire ce fichier \texttt{pdf} : \texttt{pdflatex document.tex} $\leadsto$ \texttt{document.pdf}
\footnote{Tous les exemples donnés dans ce document supposent un environnement Linux.}.  

Au sens strict, le produit de la compilation est un fichier binaire directement exécutable par l'ordinateur, voire un programme écrit dans un langage intermédiaire pouvant être exécuté par une machine virtuelle, {\cad} un logiciel émulant les fonctionnalités d'un ordinateur. Le \emph{compilateur} est le logiciel qui effectue une telle traduction. Ce traitement est habituellement terminé avant toute exécution du programme obtenu.

Dans d'autres cas, le programme source est analysé, traduit et exécuté petit à petit par un logiciel appelé \emph{interpréteur}.

Pour synthétiser, on peut retenir ceci :
\begin{description}
\item[compilé] ~\\ compilateur(programme source) $\leadsto$ fichier exécutable ; \\
  système d'exploitation(fichier exécutable) $\leadsto$ actions
\item[semi-compilé] ~\\ compilateur(programme source) $\leadsto$ programme intermédiaire ; \\
  machine virtuelle(programme intermédiaire) $\leadsto$ actions
\item[interprété] ~\\ interpréteur(programme source) $\leadsto$ actions
\end{description}

Même si un langage peut en théorie être aussi bien compilé ou interprété, il apparaît dans les faits avec une certaine implémentation. Voici quelques exemples.

\subsection{Exemples de programmes compilés}

Les programmes écrits en Haskell, Go, C peuvent être compilés respectivement avec les compilateurs ghc, golang-go, gcc.
Dans les exemples suivants, la commande de compilation, à laquelle on indique éventuellement le nom du programme source, est à gauche,
le nom du fichier exécutable produit est à droite :
\begin{itemize}
  \item \verb! ghc main.ghc ! $\leadsto$ \texttt{main}
  \item \verb! go build ! $\leadsto$ \texttt{hello}
    \footnote{ Le programme source, appelé obligatoirement \texttt{main.go}, se trouve dans un dossier appelé \texttt{hello} (nom donné au projet dans cet exemple ; le fichier exécutable prend le nom du projet), lui-même contenu dans un dossier \texttt{src} (car l'environnement Go suppose que tous les projets se trouvent dans un dossier appelé \texttt{src}. La commande de compilation \texttt{go build} est exécutée à la racine du projet, {\cad} dans le dossier \texttt{hello/src}. On voit ici qu'il y a toujours de nombreuses \emph{conventions} à connaître. }
  \item \verb! gcc main.c ! $\leadsto$ \texttt{a.out}
\end{itemize}

Les fichiers produits sont directement exécutables depuis le shell : 
\begin{itemize}
\item \verb! ./main ! $\leadsto$ actions
\item \verb! ./hello ! $\leadsto$ actions
\item \verb! ./a.out ! $\leadsto$ actions
\end{itemize}

Ces fichiers contiennent du \emph{code natif}, {\cad} un programme écrit dans un langage machine spécifique à l'environnement utilisé, à la fois en terme de système d'exploitation et d'architecture d'ordinateur. Un code natif est exécuté très rapidemment, mais ne pourra pas être exécuté sur une machine aux caractéristiques différentes de celle sur laquelle le code natif a été produit. 

\subsection{Exemple de programme semi-compilé}

Les programmes écrits en Java sont généralement compilés dans un premier en temps en \emph{byte code} par la commande \texttt{javac} :

\verb! javac Classe.java ! $\leadsto$ \texttt{Classe.class}

Dans un second temps, le \emph{byte code} est éxécuté par la machine virtuelle java, dont l'exécution est lancée par la commande \texttt{java} :

\verb! java Classe ! $\leadsto$ actions \footnote{On fournit à la commande \texttt{java} le nom complet de la classe et la machine virtuelle java charge en mémoire le byte code correspondant, contenu dans le fichier d'extension \texttt{.class}. }

C'est un compromis entre
\emph{portabilité} (le byte code produit peut être exécuté dans n'importe quel environnement pourvu qu'il y ait une machine virtuelle java\footnote{C'est ce qu'exprime le slogan ``Write once, run everywhere''.})
et \emph{rapidité d'exécution} (le byte code est suffisamment proche d'un code natif pour être exécuté relativement rapidement, d'autant que les machines virtuelles sont maintenant dotées de mécanisme de compilation à la volée pour traduire les parties du byte code les plus sollicitées en code natif).   

\subsection{Exemple de programme interprété}

\texttt{Node.js} est un interpréteur de programmes écrits en JavaScript :

\verb! node toto.js ! $\leadsto$ exécute ce qui est écrit dans le fichier \texttt{toto.js}

Les programmes interprétés sont généralement appelés \emph{scripts}. Leur exécution est plus lente, puisque l'analyse du script est effectuée au cours de l'exécution. En revanche, il est généralement possible d'exécuter des scripts incomplets, ce qui facilite leur incorporation dans d'autres contextes (HTML + JavaScript interprétés par un navigateur web par exemple). Cette souplesse accélère aussi le développement de prototypes d'application.


\section{Valeur, variable, type}

%donnée une donnée est la représentation d'une information dans un programme : soit dans le texte du programme (code source), soit en mémoire durant l'exécution.
%https://fr.wikipedia.org/wiki/Donn%C3%A9e_(informatique)
Une \emph{valeur} est une donnée, {\cad} la représentation d'une information, aussi bien dans le texte du programme source, qu'en mémoire durant l'exécution. 
Un \emph{littéral} est une valeur écrite explicitement dans le programme source, comme 2, 5.7, True, "Alice" ou encore
\begin{verbatim}
{
    "menu": {
        "id": "file",
        "value": "File",
        "popup": {
            "menuitem": [
                { "value": "New", "onclick": "CreateNewDoc()" },
                { "value": "Open", "onclick": "OpenDoc()" },
                { "value": "Close", "onclick": "CloseDoc()" }
            ]
        }
    }
}
\end{verbatim}
\'Evidemment, un programme ne contenant que des valeurs littérales ne serait pas très intéressant, car il ne serait pas capable d'adapter les actions de la machine en fonction d'informations données. Ce qui rend intéressant les programmes sont leurs variables. 

Une \emph{variable} représente une donnée susceptible de changer au cours de l'exécution ou d'une exécution à l'autre. Elle possède un nom, appelé aussi \emph{identifiant}, une \emph{valeur} stockée en mémoire au cours de l'exécution (et qui peut changer ou non), ainsi qu'un \emph{type} caractérisant les valeurs admissibles. Les variables ont également une durée de vie, appelée aussi \emph{portée}, en général limitée (pour ne pas conserver en mémoire une valeur qui serait devenue inutile).  
%compliqué à précisé. 
%qui peut être restreinte qui est le bloc, {\cad} la portion de programme bien délimitée, dans laquelle elle est déclarée ou utilisée pour la première fois.

%dessin ?

TODO typage
- implicite/explicite
- statique/dynamique

TODO type personnalisé (tableau, liste, struct/tuple/type algébriques, classe)

\section{Fonction}

Une \emph{routine} représente un sous-programme qui, à partir d'informations données, effectue un traitement spécifique, relativement indépendant du reste du programme dans lequel il peut être réutilisé plusieurs fois. Les routines permettent de décomposer un programme en parties plus faciles à écrire, modifier, tester, réutiliser. Parmi les routines, on distingue historiquement la \emph{procédure} qui déclenche une action mais ne retourne aucune valeur, de la \emph{fonction}, qui retourne une valeur et, éventuellement, réalise une opération. On emploiera ci-dessous indifférement le mot "fonction", comme c'est le cas dans de nombreux langages.    

Une fonction possède non-seulement un sous-programme, appelé \emph{corps}, mais aussi une \emph{signature}, composée d'au moins un nom et de la liste des \emph{paramètres}, {\cad} les variables dont les valeurs devront être transmises au sous-programme. A cela, s'ajoute éventuellement un type, correspondant généralement au type de la valeur de retour. 

TODO exemple

- passage de paramètre

- fonction, méthode=fonction avec contexte/fonction avec application partielle

- dans certains langages comme Haskell, une fonction est une valeur comme une autre


\section{Expression, structure de contrôle}

expression, évaluation (paresseuse), effets vs pureté, structures de contrôle


Une \emph{expression} est un agencement de signe syntaxiquement correct (littéraux, variables, opérateurs, fonctions)
\begin{itemize}
\item qui produit éventuellement une action, qu'on appelle \emph{effet}, comme le changement de la valeur de variables en mémoire ou une opération d'entrée-sortie, 
\item et qui est \emph{évalué} en une valeur. 
\end{itemize}
Le terme \emph{instruction} est généralement employé dans le cas où le résultat est ignoré et seul l'effet compte.
Voici des exemples d'expression. 

\verb! (i >= 0) && (i < 10) !, \verb! c = pgcd(a,b) !, \verb! print("hello") !

%% \subsection{Interpréteur intéractif}
%% Un \emph{REPL} (pour \emph{Read-Eval-Print Loop}) est un interpréteur intéractif dans lequel l'utilisateur est invité à taper une expression (\emph{Read}). Quand celle-ci est écrite, elle est évaluée (\emph{Eval}) en un résultat, qui est ensuite affiché à l'écran (\emph{Print}), avant que l'utilisateur soit de nouveau invité à taper une expression (\emph{Loop}). C'est très pratique pour jouer avec un langage ou inspecter ce que fait certaines parties d'un programme. 


Il existe quelques langages, dont Haskell, dits \emph{purs}, {\cad} pour lesquels il n'y a jamais d'effets.
Dans ce type de langage, une expression donnée est toujours évaluée en une et une seule valeur, sans aucun autre effet. C'est un avantage indéniable pour comprendre ce que fait une partie isolée d'un programme. En revanche, les effets sont souvent très pratiques et essentiels pour atteindre une complexité algorithmique optimale, ce qui explique qu'ils sont admis et exploités par la majorité des langages de programmation.    

pure permet paresseux

paresseux permet structure de contrôle comme fonction

\section{Polymorphisme}

- polymorphisme (interface/héritage, classe de type)

\section{Organisation du code source et conflits de nom}

à déplacer après compilation ?

\section{Erreurs et exceptions}

\section{Parallélisme et concurrence}

\section{Paradigmes de programmation}

- impératif, (CRO)
- fonctionnel, 
- objet, 
- concurrent, (PPC)

\bibliographystyle{plain}
\bibliography{refs}

\end{document}


