\documentclass [oneside,11pt]{article}

\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}

%% \usepackage[utf8]{inputenc}
%% \usepackage[T1]{fontenc}
%% \usepackage[french]{babel}

\usepackage{subfig}
\usepackage{graphicx}
\graphicspath{{fig/}}

\usepackage{amssymb}
\usepackage{amsthm}

\usepackage{hyperref}

\usepackage{cprotect} %verbatim in footnote

\newcommand{\cad}{c.-à-d.}
\newcommand{\tclogo}{LOGOSKELL}

\title{ELP, projet Haskell}
\author{Tristan Roussillon}

\begin{document}

\maketitle

Le but de ce projet est de développer en Haskell un outil qui transforme un programme écrit dans un langage inspiré des langages \href{https://fr.wikipedia.org/wiki/Logo_(langage)}{Logo} et Haskell en un programme écrit en \href{https://fr.wikipedia.org/wiki/Scalable_Vector_Graphics}{SVG}. 

Il doit être réalisé en binôme et à rendre sous la forme d'une archive au format \verb!zip! contenant un fichier haskell commenté (explications nécessaires à la bonne compréhension du code, à la compilation et à l'utilisation correcte de l'exécutable). Le nom de l'archive doit être composé du nom et prénom des deux étudiants et être déposé sur \href{https://moodle.insa-lyon.fr/}{Moodle} au plus tard le 18 Décembre 2020, 23h55.  

\section{Le langage {\tclogo}}
Le langage {\tclogo} (version 1.0) sert à exprimer le chemin que va suivre un crayon pour dessiner un graphique. Il comporte 4 instructions, toutes avec paramètres : {\tt Forward}, {\tt Left}, {\tt Right} et {\tt Repeat}. L'instruction {\tt Forward x} fait avancer le crayon de x points dans la direction courante. L'instruction {\tt Right x} (respectivement {\tt Left x}) fait tourner la direction courante de x degrés à droite (respectivement à gauche), dans le sens des aiguilles d'une montre (respectivement dans le sens inverse). L'instruction {\tt Repeat x [ yyy ]} répète x fois la suite d'instructions entre crochets. Les instructions sont séparées par des virgules et le programme entier se trouve entre crochets et sur une seule ligne de texte. 

Le programme suivant décrit la \textsc{Figure}~\ref{fig} :
\begin{verbatim}
[Forward 100, Repeat  4 [Forward 50, Left 90], Forward 100]
\end{verbatim}

\begin{figure}
\includegraphics{ex1.pdf}
\caption{La représentation graphique décrite par le programme {\tclogo} donné, avec comme point et direction de départ l'origine et l'angle nul.}
\label{fig}
\end{figure}

\newpage

La même \textsc{Figure}~\ref{fig} est décrite par le programme SVG suivant, interprétable dans n'importe quel navigateur :
{\scriptsize
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="200" height="200">
<title>Exemple</title>
<line x1="100.000" y1="100.000" x2="200.000" y2="100.000" stroke="red" />
<line x1="200.000" y1="100.000" x2="250.000" y2="100.000" stroke="red" />
<line x1="250.000" y1="100.000" x2="250.000" y2="150.000" stroke="red" />
<line x1="250.000" y1="150.000" x2="200.000" y2="150.000" stroke="red" />
<line x1="200.000" y1="150.000" x2="200.000" y2="100.000" stroke="red" />
<line x1="200.000" y1="100.000" x2="300.000" y2="100.000" stroke="red" />
</svg>
\end{verbatim}
}

Votre objectif est d'écrire en Haskell un programme capable de lire en entrée un programme {\tclogo}, comme celui donné plus haut, et d'écrire en sortie un programme SVG représentant la même figure.

\section{Méthodologie}
Le projet peut être décomposé en deux étapes : 
\begin{itemize}
\item Développement d'une structure de données représentant un programme {\tclogo}, 
\item Traitement de cette représentation intermédiaire pour produire un programme SVG. 
\end{itemize}

\subsection{Étape 1: Représentation intermédiaire}

Vous devez proposer une structure de données pour stocker votre programme {\tclogo} en mémoire, puis pouvoir produire du code à partir de cette représentation intermédiaire. Pour commencer, vérifiez que : 
\begin{itemize}
\item Un programme {\tclogo} est une liste d'instructions.
\item Chaque instruction possède un ou plusieurs paramètres.
\item Ces paramètres peuvent être des entiers ou des programmes (voir {\tt Repeat}). 
\end{itemize}

Le programme {\tclogo} précédent peut être considéré comme un programme haskell valide à partir du moment où il existe des constructeurs de valeur correspondant aux 4 instructions {\tt Forward}, {\tt Left}, {\tt Right} et {\tt Repeat}. Cela fait partie de votre travail de définir les constructeurs et types correspondants. Par exemple, vous pouvez définir le type \verb!Instruction! ainsi :
\begin{verbatim}
data Instruction = Forward Int
\end{verbatim}
et alors traiter dans un programme haskell n'importe quelles valeurs du type \verb!Instruction! comme \verb!Forward 100! ou d'un type paramétré par \verb!Instruction!, comme \verb![Forward 50, Forward 50]! qui est de type \verb![Instruction]!. Nous ne sommes déjà pas très loin des spécifications du {\tclogo}\footnote{Un constructeur appelé \verb!Left! ou \verb!Right! produira une erreur car il existe déjà un type (\verb!Either!) défini à l'aide de constructeurs nommés \verb!Left! et \verb!Right! automatiquement importés du Prélude. Pour lever le conflit de nom, il suffit de cacher les constructeurs issus du Prélude à l'aide de la ligne de code \verb!import Prelude hiding (Left, Right)!, placée en première position.}. 

De plus, nous ne voulons pas écrire un programme {\tclogo} dans le code du compilateur, mais plutôt lire ce programme à l'exécution. Dans ce cas, il est représenté dans le code par une chaîne de caractère. A l'échelle d'une instruction, la question qui se pose est comment passer d'une chaîne de caractère représentant l'instruction en une valeur de type \verb!Instruction! ? ou concrètement, comment passer de la chaîne de caractère \verb!"Forward 100"! à la valeur \verb!Forward 100! (attention à la présence ou absence des guillemets) ? Il existe une fonction, appelée \verb!read!, qui fait cette transformation si le type en question (\verb!Instruction! dans cet exemple) appartient à la classe \verb!Read!, ce qu'on indique en ajoutant la clause \verb!deriving! à la définition du type :
\begin{verbatim}
  data Instruction = Forward Int deriving (Show, Read)
  uneInstruction = (read "Forward 100" :: Instruction)
\end{verbatim}

Enfin, il est nécessaire pour la seconde étape de pouvoir extraire les paramètres d'une instruction. Autrement dit, comment, étant donnée une variable de type \verb!Instruction!, accéder à l'entier caractérisant l'instruction ? Simplement par \emph{pattern matching}. Par exemple :
\begin{verbatim}
Forward x = uneInstruction 
-- x vaut 100 
\end{verbatim}

\section{Étape 2: génération d'un fichier SVG}

Vous devez écrire une fonction qui prend en entrée une représentation intermédiaire, ainsi qu'un crayon caractérisé par une position et une direction, et retourne un programme SVG. Il y a de nombreuses possibilités et vous êtes libres de choisir celle qui vous semble pertinente.

L'une d'elle consiste à séparer la tâche de traduction des tâches d'entrée-sortie et d'écrire une fonction pure qui utilise un accumulateur pour stocker les lignes du programme SVG calculé. 
\begin{verbatim}
logoskell2svg :: Programme -> Crayon -> [String] 
  -> (Crayon, [String])
\end{verbatim}
où je suppose que les types \verb!Programme! et \verb!Crayon! ont été correctement définis. Remarquez que le crayon et la liste des lignes SVG déjà connues est un contexte de calcul dont on voudrait habituellement modifier l'état au cours de l'exécution. Comme Haskell est un langage pur n'autorisant pas de mise à jour, la stratégie courante consiste à passer en paramètre et retourner le contexte de calcul. 

Il reste alors à écrire une seconde fonction qui affiche la liste des lignes SVG sur la sortie standard\footnote{Si vous ne savez pas ce que sont l'entrée et la sortie standards, les redirections de flux, consultez la page suivante : \url{https://www.tuteurs.ens.fr/unix/shell/entreesortie.html}}. 
\begin{verbatim}
outputStrLst :: [String] -> IO() 
\end{verbatim}

Plutôt que stocker les lignes du programme SVG calculé, vous pouvez aussi ne stocker que les extrémités des segments de droite. Dans ce cas, la signature des fonctions ressemblera à :  
\begin{verbatim}
logoskell2svg :: Programme -> Crayon -> [Point] 
  -> (Crayon, [Point])
outputPtLst :: [Point] -> IO() 
\end{verbatim}

Tout ce que vous lisez dans cette section ne sont que des indications et votre solution peut tout à fait être différente.

\newpage

\appendix

\section{Exemple}

J'ai écris un tel programme en moins de 60 lignes. L'éxécutable appelé \verb!compilateurLogoskell! lit un programme {\tclogo} sur l'entrée standard et écrit le programme SVG équivalent sur la sortie standard :
\begin{verbatim}
./compilateurLogoskell < prog.logo > prog.svg 
\end{verbatim}
où le fichier \verb!prog.logo! contient par exemple :
\begin{verbatim}
[ Repeat 36 [ Right 10, Repeat 8 [ Forward 25, Left 45 ] ] ]
\end{verbatim}

Et voici comment s'affiche dans ce cas le fichier \verb!prog.svg! obtenu : 
\begin{center}
  \includegraphics{crazy.pdf}
\end{center}
\end{document}
