Type tuple polymorphe
-------------------------

Un *type polymorphe* est composé d'au moins une famille de type.

.. code-block:: haskell

   data Point a = Pt a a

Par exemple, à partir de tout type ``a``, le constructeur de type ``Point``
définit ``Point a``, le type des points cartésiens ayant ``a`` comme coordonnées. 

Le constructeur de valeur ``Pt :: a -> a -> Point a`` est une manière d'obtenir
des valeurs de type ``Point a``. Par exemple, ``Pt 2.0 3.0`` est le point :math:`(2,3)`.

Avertissement
-------------------------

Les constructeurs de type comme ``Point`` et les constructeurs de valeurs comme ``Pt``
se trouvent dans des espaces de noms séparés. Il est donc possible de donner le même nom
aux deux constructeurs, afin de rendre plus évident le lien entre un type et le constructeur
de valeur associé. 

.. literalinclude:: code/shape.hs
   :language: haskell
   :lines: 1

Type énuméré polymorphe
--------------------------

.. literalinclude:: code/shape.hs
   :language: haskell
   :lines: 3-4

Autrement dit, le type ``Shape a`` correspond soit à un cercle
(défini par un point de type ``Point a`` et un rayon de type ``a``),
soit à un rectangle (défini par deux points de type ``Point a``).  
	   
.. literalinclude:: code/shape.hs
   :language: haskell
   :lines: 7-12

Arbre
----------


.. literalinclude:: code/tree2.hs
   :language: haskell
   :lines: 1

Autrement dit, une valeur de type ``Tree a`` est un arbre binaire polymorphe
dont les éléments sont soit une feuille (contenant une valeur de type ``a``),
soit un noeud interne reliant deux sous-arbres.      

.. literalinclude:: code/tree2.hs
   :language: haskell
   :lines: 3-9

Défi 5 : tas de cartes
------------------------

- Définissez le type d'une carte à jouer.
- Définissez le type d'un tas de carte.
- Créez le tas de carte à l'aide d'une *list comprehension*. 
- Donnez l'expression indiquant le nombre de cartes se trouvant dans le tas. 

  
Défi 1 : construire un arbre
---------------------------------

.. figure:: figs/arbre.svg
   :width: 250pt
   :alt: arbre
   :align: center

.. code-block:: none

   *Main> flatten (Node (Node (Leaf 'a') (Leaf 'b')) (Leaf 'c'))
   "abc"

     
Défi 2 : hauteur d'un arbre binaire
--------------------------------------

.. literalinclude:: code/treeHeight.hs
   :language: haskell

Défi 3 : définir un type d'arbre
------------------------------------------

.. literalinclude:: code/tree3.hs
   :language: haskell


.. _carte-label:
   
Défi 5 : tas de cartes
------------------------

.. literalinclude:: code/carte2.hs
   :language: haskell

.. code-block:: none

   *Main> length leTas
   52

(Inspiré de ce `tutoriel <https://wiki.haskell.org/Type>`_)

Défi 1 : construire un arbre
---------------------------------

A l'aide des définitions précédentes,
construisez l'arbre représenté ci-dessous,
et passez-le comme argument à la fonction ``flatten`` dans GHCi. 

.. figure:: figs/arbre.svg
   :width: 250pt 
   :alt: arbre
   :align: center

Défi 2 : hauteur d'un arbre binaire
--------------------------------------

Définissez la fonction

.. literalinclude:: code/treeHeight.hs
   :language: haskell
   :lines: 3

qui, pour un arbre donné, renvoie la longueur du plus long chemin entre
la racine et une feuille, c'est-à-dire la hauteur de l'arbre :

.. code-block:: none

   *Main> treeHeight (Leaf 4)
   1
   *Main> treeHeight (Node (Leaf 4) (Leaf 5))
   2
   *Main> treeHeight (Node (Leaf 4) (Node (Leaf 5) (Leaf 6)))
   3

		
.. Défi 2 : aplatir un arbre binaire
   -----------------------------------

   Proposez une version plus efficace de ``flatten``
   en utilisant l'opérateur ``(:)`` au lieu de l'opérateur ``(++)``. 

   .. code-block:: none

      *Main> flatten (Node (Node (Leaf 1) (Leaf 2)) (Leaf 3)) 
      [1,2,3]

   Astuce : comme pour :ref:`MyReverse<reversecode>`, définissez une fonction intermédiaire
   qui prend en entrée l'arbre et une liste temporaire d'accumulation. 

   .. code-block:: Haskell

      flatten' :: Tree a -> [a] -> [a] 

	   
.. Défi 3 : liste imbriquée
   -----------------------------------

   Après avoir défini le type adéquat, écrivez la fonction

   .. literalinclude:: code/NestedList.hs
      :language: haskell
      :lines: 3

   qui aplatit une liste d'élément
   pouvant contenir des listes comme élément.  

   .. code-block:: none

      *Main> flatten (Elem 5)
      [5]
      *Main> flatten (List [Elem 1, List [Elem 2, List [Elem 3, Elem 4]]])
      [1,2,3,4]
      *Main> flatten (List [])
      []

Défi 3 : définir un type d'arbre 
------------------------------------
	   
- Définissez le type d'un arbre binaire dans lequel chaque noeud est :
  
  - soit vide,
  - soit la racine de deux sous-arbres et porteur d'une donnée de type arbitraire.

- Définissez une variante de la fonction ``flatten`` pour aplatir cet arbre en une liste.      



Exemple
-----------------

.. literalinclude:: code/isSorted.hs
   :language: haskell


Literate programming
------------------------------

Donald Knuth (1938-) est à l'origine de cette pratique appelée *literate programming*. L'idée est de concevoir un programme informatique comme un texte écrit en langue naturelle dans lequel on insère des portions de code.

.. premier outil (CWEB) pour désemmeler les portions de code et
   reconstruire le programme source
   (car le meilleur ordre de présentation n'est pas forcément l'ordre imposé par le langage choisi).
   
Dans les fichiers d'extension ``.lhs``, seules les lignes précédées par ``>`` et espace (*Bird style*)
sont considérées comme du code Haskell.
Ils sont compilés comme ceux d'extension ``.hs``, car Haskell supporte nativement cette convention. 
Essayez cet :download:`exemple<download/isSorted.lhs>`. 

défi 4 : tracer une évaluation
-------------------------------------

Soient les fonctions suivantes : 

.. literalinclude:: code/take-repeat.hs
   :language: haskell

Tracez (sur papier) l'évaluation de : 

.. code-block:: haskell

    take 3 (repeat 7)

défi 4 : tracer une évaluation (aussi `là <http://www.cis.upenn.edu/~cis194/spring13/lectures/06-laziness.html>`_)
---------------------------------------------------------------------------------------------------------------------

.. code-block:: none


      take 3 (repeat 7)
          { 3 <= 0 is False, so we proceed to the second clause, which
	    needs to match on the second argument. So we must expand
	    repeat 7 one step. }
    = take 3 (7 : repeat 7)
          { the second clause does not match but the third clause
            does. Note that (3-1) does not get evaluated yet! }
    = 7 : take (3-1) (repeat 7)
          { In order to decide on the first clause, we must test (3-1)
            <= 0 which requires evaluating (3-1). }
    = 7 : take 2 (repeat 7)
          { 2 <= 0 is False, so we must expand repeat 7 again. }
    = 7 : take 2 (7 : repeat 7)
          { The rest is similar. }
    = 7 : 7 : take (2-1) (repeat 7)
    = 7 : 7 : take 1 (repeat 7)
    = 7 : 7 : take 1 (7 : repeat 7)
    = 7 : 7 : 7 : take (1-1) (repeat 7)
    = 7 : 7 : 7 : take 0 (repeat 7)
    = 7 : 7 : 7 : [] = [7,7,7]



défi bonus. ``group``
-------------------------

Définissez la fonction

.. literalinclude:: code/group.hs
   :language: haskell
   :lines: 1

qui regroupe les éléments égaux consécutifs en une sous-liste. 
Par exemple :

.. code-block:: none

   *Main> group "aaaabccaadeeee"
   ["aaaa","b","cc","aa","d","eeee"]

Astuce : ``head lst`` fournit le premier élément de ``lst``. 
   
défi bonus. ``slice``
--------------------------

Définissez la fonction 

.. literalinclude:: code/slice.hs
   :language: haskell
   :lines: 1

qui extrait d'une liste donnée, une sous-liste déterminée par deux indices.
Par exemple :

.. code-block:: none

    *Main> slice "abcdefghij" 3 7
    "cdefg"

Astuce : quand le premier indice est ``1``, ``slice`` se comporte comme ``split``.
    
défi bonus. ``group``
-------------------------

.. literalinclude:: code/group.hs
   :language: haskell

défi bonus. ``slice``
-------------------------

.. literalinclude:: code/slice.hs
   :language: haskell


Défi 3 : ``filter``
-------------------------

En utilisant la fonction ``filter``, ainsi que les opérateurs ``==`` (égalité)
et ``/=`` (différence), définissez récursivement la fonction  

.. literalinclude:: code/group2.hs
   :language: haskell
   :lines: 1

qui retourne une liste regroupant tous les éléments égaux dans des sous-listes. 

.. code-block:: none

   *Main> group "banana"
   ["b","aaa","nn"]

Défi 4 : ``map``
---------------------------------

En utilisant la fonction ``map``, définissez la fonction  

.. literalinclude:: code/encode2.hs
   :language: haskell
   :lines: 1

qui retourne la liste des différents éléments et de leur répétition
dans une liste donnée.
	   
.. code-block:: none

   *Main> encode "banana"
   [('b',1),('a',3),('n',2)]

Défi 6 : reverse par foldl 
----------------------------

Définissez la fonction

.. literalinclude:: code/reverse3.hs
   :language: haskell
   :lines: 1

en utilisant la fonction ``foldl`` (une ligne de code).

Défi 6 : reverse par foldl 
----------------------------

.. literalinclude:: code/reverse3.hs
   :language: haskell

.. Défi 6 : sommation 
   -----------------------

   Définissez la fonction

   .. literalinclude:: code/mySum.hs
      :language: haskell
      :lines: 1

   en utilisant la fonction ``foldr``.

   .. code-block:: none

      *Main> mySum [1..10]
      55



Evaluation paresseuse
========================

Qu'est-ce que la paresse ? 
----------------------------

En Haskell, les expressions ne sont pas évaluées tant que leur valeur n'est pas requise.
Quand une expression est donnée en argument à une fonction, celle-ci est simplement mémorisée
dans une structure dédiée aux expressions non évaluées, sans aucun traitement supplémentaire. 

- Les expressions sont évaluées lors d'une mise en correspondance avec un motif. 
- Mais elles ne sont pas évaluées complètement, seulement du minimum requis pour la mise en correspondance.

Exemple
-------------------------

Soit la fonction suivante :

.. code-block:: haskell

    f x _ = x + 2		

NB. ``_`` est un *joker* qui évite de conserver la valeur associée
quand on en n'a pas besoin dans la partie droite.

Les évaluations suivantes seront immédiates car le second argument
ne sera jamais évalué : 
    
.. code-block:: haskell

    f 5 (29^35792)		
    f 5 (1/0)		

Paresse implique pureté
---------------------------
    
Un langage pur est un langage sans effet de bord.
Les effets de bord sont des effets de l'évaluation d'une expression sur l'extérieur. 
Or ces effets surviennent dans un ordre temporel qui a de l'importance
pour le bon fonctionnement du programme.

Par exemple : 

- le moment auquel on modifie une variable globale importe, car cela pourrait affecter l'évaluation d'autres expressions.
- le moment auquel on écrit à l'écran importe, car cela pourrait affecter l'ordre d'affichage des messages.  

La paresse, qui gomme l'ordre temporel des traitements, requière donc l'absence d'effet de bord. 

Défi 1 : tracer une évaluation
-------------------------------------

Soient les fonctions suivantes : 

.. literalinclude:: code/take-repeat.hs
   :language: haskell

Tracez (sur papier) l'évaluation de : 

.. code-block:: haskell

    take 3 (repeat 7)

Complexité
---------------------------

Soit la fonction suivante

.. literalinclude:: code/reverse1.hs
   :language: haskell

où

.. literalinclude:: code/concat.hs
   :language: haskell

Pour avoir une idée de la complexité
de ce code, nous allons tracer l'évaluation
de ``myReverse [1,2,3,4]``.  
	      
Trace 
---------------------------

.. code-block:: none

    myReverse [1,2,3,4] {second motif de myReverse}
    = myReverse [2,3,4] ++ [1]
    {le premier argument de (++) est évalué pour le matching}
    = (myReverse [3,4] ++ [2]) ++ [1] {même chose...}
    = ((myReverse [4] ++ [3]) ++ [2]) ++ [1]		
    = (((myReverse [] ++ [4]) ++ [3]) ++ [2]) ++ [1] {premier motif}		
    = ((([] ++ [4]) ++ [3]) ++ [2]) ++ [1] {premier motif de (++)}
    = (([4] ++ [3]) ++ [2]) ++ [1] {second motif de (++)}
    = ((4 : [] ++ [3]) ++ [2]) ++ [1] 
    {le second motif de (++) est immédiatement choisi,
    car (4 : [] ++ [3]) correspond clairement à (x:xs)}
    = (4 : ([] ++ [3]) ++ [2]) ++ [1] {même chose...}
    = 4 : (([] ++ [3]) ++ [2]) ++ [1] 
    {il reste à évaluer le second argument de (:) pour obtenir la liste,
    donc pour chaque élément on remonte la suite de concaténations...}

    
Défi 2 : complexité
----------------------------

Pour la version suivante, tracez (sur papier) l'évaluation de ``myReverse [1,2,3,4]``.
D'après vous, quelle est la complexité de cette version de ``myReverse`` ?

.. _reversecode:

.. literalinclude:: code/reverse2.hs
   :language: haskell


Conséquence 1 : structures de contrôle 
----------------------------------------

.. code-block:: haskell

    myBinaryAnd e1 e2 = case (e1, e2) of
		(False, _) -> False
		(True, x) -> x
		
.. code-block:: haskell

    myIf cond e1 e2 = case (cond, e1, e2) of
		       (True, e1, _) -> e1
		       (False, _, e2) -> e2

Grâce à la paresse, les deux appels suivants retournent immédiatement.  

.. code-block:: haskell

    myBinaryAnd False (head [] == 'x')
    myIf True 2 (34^9784346 > 34987345) 		



Conséquence 2 : structures de données infinies
-----------------------------------------------

.. literalinclude:: code/numsFrom.hs
   :language: haskell
		
.. code-block:: none

   *Main> numsFrom 1
   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,
   27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,
   50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,
   73,74,75,76,77,78,79,80,81Interrupted.

.. code-block:: none

   *Main> take 5 (numsFrom 1)
   [1,2,3,4,5]

   
Conséquence 3 : pipeline par composition
------------------------------------------

.. literalinclude:: code/pipelines.hs
   :language: haskell

Ce programme d'une ligne compte et affiche sur la sortie standard la taille des lignes lues sur l'entrée standard.
A ce stade, vous n'avez pas besoin de comprendre chaque fonction (cf. `Hoogle <https://www.haskell.org/hoogle/>`_
pour en savoir plus), seulement que l'opérateur ``.`` est l'opérateur
de composition : :math:`f \circ g` s'écrit ``f . g`` en Haskell. 

Bien que le programme ne soit qu'une suite de compositions, l'affichage commence avant que toutes les lignes soient lues.
En effet, grâce à l'évaluation paresseuse, dès qu'une ligne est lue, sa taille est aussitôt affichée. A essayer!


.. Typage statique
   ---------------------------      
      
   - Chaque valeur à un type associé.
   - Les types sont vérifiés à la compilation.

   .. figure:: figs/type.svg
      :width: 80%
      :alt: types et typage
      :align: center


Déclarations
-------------------

On a vu pour l'instant deux sortes de déclarations :

- *equation*
- *type signature*

On va maintenant en voir d'autres : 
  
- ``data`` declaration (créer un type)
- ``type`` declaration (créer un synonyme de type)

  .. - ``newtype`` declaration (créer un type à partir d'un autre)

- ``class`` declaration (créer un groupe de type)
- ``instance`` declaration (déclarer un type comme appartenant à un groupe donné) 



Défi bonus. ``toIntList``
---------------------------

- Créez la classe ``IntListable`` dotée de la fonction

.. code-block:: haskell

   toIntList :: IntListable a => a -> [Int]

- Faites de

  - ``Int``,
  - ``Bool``,
  - ``[Int]``,
  - une paire d'élément ``IntListable``,
  
  des instances de cette classe. 


Défi bonus. ``toIntList``
---------------------------

.. literalinclude:: code/toIntList.hs
   :language: haskell

(Inspiré de cette `leçon <http://www.cis.upenn.edu/~cis194/spring13/lectures/05-type-classes.html>`_)

