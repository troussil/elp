Exemple
-----------------

.. literalinclude:: code/isSorted.hs
   :language: haskell


Literate programming
------------------------------

Donald Knuth (1938-) est à l'origine de cette pratique appelée *literate programming*. L'idée est de concevoir un programme informatique comme un texte écrit en langue naturelle dans lequel on insère des portions de code.

.. premier outil (CWEB) pour désemmeler les portions de code et
   reconstruire le programme source
   (car le meilleur ordre de présentation n'est pas forcément l'ordre imposé par le langage choisi).
   
Dans les fichiers d'extension ``.lhs``, seules les lignes précédées par ``>`` et espace (*Bird style*)
sont considérées comme du code Haskell.
Ils sont compilés comme ceux d'extension ``.hs``, car Haskell supporte nativement cette convention. 
Essayez cet :download:`exemple<download/isSorted.lhs>`. 

défi 4 : tracer une évaluation
-------------------------------------

Soient les fonctions suivantes : 

.. literalinclude:: code/take-repeat.hs
   :language: haskell

Tracez (sur papier) l'évaluation de : 

.. code-block:: haskell

    take 3 (repeat 7)

défi 4 : tracer une évaluation (aussi `là <http://www.cis.upenn.edu/~cis194/spring13/lectures/06-laziness.html>`_)
---------------------------------------------------------------------------------------------------------------------

.. code-block:: none


      take 3 (repeat 7)
          { 3 <= 0 is False, so we proceed to the second clause, which
	    needs to match on the second argument. So we must expand
	    repeat 7 one step. }
    = take 3 (7 : repeat 7)
          { the second clause does not match but the third clause
            does. Note that (3-1) does not get evaluated yet! }
    = 7 : take (3-1) (repeat 7)
          { In order to decide on the first clause, we must test (3-1)
            <= 0 which requires evaluating (3-1). }
    = 7 : take 2 (repeat 7)
          { 2 <= 0 is False, so we must expand repeat 7 again. }
    = 7 : take 2 (7 : repeat 7)
          { The rest is similar. }
    = 7 : 7 : take (2-1) (repeat 7)
    = 7 : 7 : take 1 (repeat 7)
    = 7 : 7 : take 1 (7 : repeat 7)
    = 7 : 7 : 7 : take (1-1) (repeat 7)
    = 7 : 7 : 7 : take 0 (repeat 7)
    = 7 : 7 : 7 : [] = [7,7,7]



défi bonus. ``group``
-------------------------

Définissez la fonction

.. literalinclude:: code/group.hs
   :language: haskell
   :lines: 1

qui regroupe les éléments égaux consécutifs en une sous-liste. 
Par exemple :

.. code-block:: none

   *Main> group "aaaabccaadeeee"
   ["aaaa","b","cc","aa","d","eeee"]

Astuce : ``head lst`` fournit le premier élément de ``lst``. 
   
défi bonus. ``slice``
--------------------------

Définissez la fonction 

.. literalinclude:: code/slice.hs
   :language: haskell
   :lines: 1

qui extrait d'une liste donnée, une sous-liste déterminée par deux indices.
Par exemple :

.. code-block:: none

    *Main> slice "abcdefghij" 3 7
    "cdefg"

Astuce : quand le premier indice est ``1``, ``slice`` se comporte comme ``split``.
    
défi bonus. ``group``
-------------------------

.. literalinclude:: code/group.hs
   :language: haskell

défi bonus. ``slice``
-------------------------

.. literalinclude:: code/slice.hs
   :language: haskell


Défi 3 : ``filter``
-------------------------

En utilisant la fonction ``filter``, ainsi que les opérateurs ``==`` (égalité)
et ``/=`` (différence), définissez récursivement la fonction  

.. literalinclude:: code/group2.hs
   :language: haskell
   :lines: 1

qui retourne une liste regroupant tous les éléments égaux dans des sous-listes. 

.. code-block:: none

   *Main> group "banana"
   ["b","aaa","nn"]

Défi 4 : ``map``
---------------------------------

En utilisant la fonction ``map``, définissez la fonction  

.. literalinclude:: code/encode2.hs
   :language: haskell
   :lines: 1

qui retourne la liste des différents éléments et de leur répétition
dans une liste donnée.
	   
.. code-block:: none

   *Main> encode "banana"
   [('b',1),('a',3),('n',2)]

Défi 6 : reverse par foldl 
----------------------------

Définissez la fonction

.. literalinclude:: code/reverse3.hs
   :language: haskell
   :lines: 1

en utilisant la fonction ``foldl`` (une ligne de code).

Défi 6 : reverse par foldl 
----------------------------

.. literalinclude:: code/reverse3.hs
   :language: haskell

.. Défi 6 : sommation 
   -----------------------

   Définissez la fonction

   .. literalinclude:: code/mySum.hs
      :language: haskell
      :lines: 1

   en utilisant la fonction ``foldr``.

   .. code-block:: none

      *Main> mySum [1..10]
      55



Evaluation paresseuse
========================

Qu'est-ce que la paresse ? 
----------------------------

En Haskell, les expressions ne sont pas évaluées tant que leur valeur n'est pas requise.
Quand une expression est donnée en argument à une fonction, celle-ci est simplement mémorisée
dans une structure dédiée aux expressions non évaluées, sans aucun traitement supplémentaire. 

- Les expressions sont évaluées lors d'une mise en correspondance avec un motif. 
- Mais elles ne sont pas évaluées complètement, seulement du minimum requis pour la mise en correspondance.

Exemple
-------------------------

Soit la fonction suivante :

.. code-block:: haskell

    f x _ = x + 2		

NB. ``_`` est un *joker* qui évite de conserver la valeur associée
quand on en n'a pas besoin dans la partie droite.

Les évaluations suivantes seront immédiates car le second argument
ne sera jamais évalué : 
    
.. code-block:: haskell

    f 5 (29^35792)		
    f 5 (1/0)		

Paresse implique pureté
---------------------------
    
Un langage pur est un langage sans effet de bord.
Les effets de bord sont des effets de l'évaluation d'une expression sur l'extérieur. 
Or ces effets surviennent dans un ordre temporel qui a de l'importance
pour le bon fonctionnement du programme.

Par exemple : 

- le moment auquel on modifie une variable globale importe, car cela pourrait affecter l'évaluation d'autres expressions.
- le moment auquel on écrit à l'écran importe, car cela pourrait affecter l'ordre d'affichage des messages.  

La paresse, qui gomme l'ordre temporel des traitements, requière donc l'absence d'effet de bord. 

Défi 1 : tracer une évaluation
-------------------------------------

Soient les fonctions suivantes : 

.. literalinclude:: code/take-repeat.hs
   :language: haskell

Tracez (sur papier) l'évaluation de : 

.. code-block:: haskell

    take 3 (repeat 7)

Complexité
---------------------------

Soit la fonction suivante

.. literalinclude:: code/reverse1.hs
   :language: haskell

où

.. literalinclude:: code/concat.hs
   :language: haskell

Pour avoir une idée de la complexité
de ce code, nous allons tracer l'évaluation
de ``myReverse [1,2,3,4]``.  
	      
Trace 
---------------------------

.. code-block:: none

    myReverse [1,2,3,4] {second motif de myReverse}
    = myReverse [2,3,4] ++ [1]
    {le premier argument de (++) est évalué pour le matching}
    = (myReverse [3,4] ++ [2]) ++ [1] {même chose...}
    = ((myReverse [4] ++ [3]) ++ [2]) ++ [1]		
    = (((myReverse [] ++ [4]) ++ [3]) ++ [2]) ++ [1] {premier motif}		
    = ((([] ++ [4]) ++ [3]) ++ [2]) ++ [1] {premier motif de (++)}
    = (([4] ++ [3]) ++ [2]) ++ [1] {second motif de (++)}
    = ((4 : [] ++ [3]) ++ [2]) ++ [1] 
    {le second motif de (++) est immédiatement choisi,
    car (4 : [] ++ [3]) correspond clairement à (x:xs)}
    = (4 : ([] ++ [3]) ++ [2]) ++ [1] {même chose...}
    = 4 : (([] ++ [3]) ++ [2]) ++ [1] 
    {il reste à évaluer le second argument de (:) pour obtenir la liste,
    donc pour chaque élément on remonte la suite de concaténations...}

    
Défi 2 : complexité
----------------------------

Pour la version suivante, tracez (sur papier) l'évaluation de ``myReverse [1,2,3,4]``.
D'après vous, quelle est la complexité de cette version de ``myReverse`` ?

.. _reversecode:

.. literalinclude:: code/reverse2.hs
   :language: haskell


Conséquence 1 : structures de contrôle 
----------------------------------------

.. code-block:: haskell

    myBinaryAnd e1 e2 = case (e1, e2) of
		(False, _) -> False
		(True, x) -> x
		
.. code-block:: haskell

    myIf cond e1 e2 = case (cond, e1, e2) of
		       (True, e1, _) -> e1
		       (False, _, e2) -> e2

Grâce à la paresse, les deux appels suivants retournent immédiatement.  

.. code-block:: haskell

    myBinaryAnd False (head [] == 'x')
    myIf True 2 (34^9784346 > 34987345) 		



Conséquence 2 : structures de données infinies
-----------------------------------------------

.. literalinclude:: code/numsFrom.hs
   :language: haskell
		
.. code-block:: none

   *Main> numsFrom 1
   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,
   27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,
   50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,
   73,74,75,76,77,78,79,80,81Interrupted.

.. code-block:: none

   *Main> take 5 (numsFrom 1)
   [1,2,3,4,5]

   
Conséquence 3 : pipeline par composition
------------------------------------------

.. literalinclude:: code/pipelines.hs
   :language: haskell

Ce programme d'une ligne compte et affiche sur la sortie standard la taille des lignes lues sur l'entrée standard.
A ce stade, vous n'avez pas besoin de comprendre chaque fonction (cf. `Hoogle <https://www.haskell.org/hoogle/>`_
pour en savoir plus), seulement que l'opérateur ``.`` est l'opérateur
de composition : :math:`f \circ g` s'écrit ``f . g`` en Haskell. 

Bien que le programme ne soit qu'une suite de compositions, l'affichage commence avant que toutes les lignes soient lues.
En effet, grâce à l'évaluation paresseuse, dès qu'une ligne est lue, sa taille est aussitôt affichée. A essayer!


.. Typage statique
   ---------------------------      
      
   - Chaque valeur à un type associé.
   - Les types sont vérifiés à la compilation.

   .. figure:: figs/type.svg
      :width: 80%
      :alt: types et typage
      :align: center


Déclarations
-------------------

On a vu pour l'instant deux sortes de déclarations :

- *equation*
- *type signature*

On va maintenant en voir d'autres : 
  
- ``data`` declaration (créer un type)
- ``type`` declaration (créer un synonyme de type)

  .. - ``newtype`` declaration (créer un type à partir d'un autre)

- ``class`` declaration (créer un groupe de type)
- ``instance`` declaration (déclarer un type comme appartenant à un groupe donné) 



Défi bonus. ``toIntList``
---------------------------

- Créez la classe ``IntListable`` dotée de la fonction

.. code-block:: haskell

   toIntList :: IntListable a => a -> [Int]

- Faites de

  - ``Int``,
  - ``Bool``,
  - ``[Int]``,
  - une paire d'élément ``IntListable``,
  
  des instances de cette classe. 


Défi bonus. ``toIntList``
---------------------------

.. literalinclude:: code/toIntList.hs
   :language: haskell

(Inspiré de cette `leçon <http://www.cis.upenn.edu/~cis194/spring13/lectures/05-type-classes.html>`_)

