Exemple
-----------------

.. literalinclude:: code/isSorted.hs
   :language: haskell


Literate programming
------------------------------

Donald Knuth (1938-) est à l'origine de cette pratique appelée *literate programming*. L'idée est de concevoir un programme informatique comme un texte écrit en langue naturelle dans lequel on insère des portions de code.

.. premier outil (CWEB) pour désemmeler les portions de code et
   reconstruire le programme source
   (car le meilleur ordre de présentation n'est pas forcément l'ordre imposé par le langage choisi).
   
Dans les fichiers d'extension ``.lhs``, seules les lignes précédées par ``>`` et espace (*Bird style*)
sont considérées comme du code Haskell.
Ils sont compilés comme ceux d'extension ``.hs``, car Haskell supporte nativement cette convention. 
Essayez cet :download:`exemple<download/isSorted.lhs>`. 




    



Evaluation paresseuse
========================

Qu'est-ce que la paresse ? 
----------------------------

En Haskell, les expressions ne sont pas évaluées tant que leur valeur n'est pas requise.
Quand une expression est donnée en argument à une fonction, celle-ci est simplement mémorisée
dans une structure dédiée aux expressions non évaluées, sans aucun traitement supplémentaire. 

- Les expressions sont évaluées lors d'une mise en correspondance avec un motif. 
- Mais elles ne sont pas évaluées complètement, seulement du minimum requis pour la mise en correspondance.

Exemple
-------------------------

Soit la fonction suivante :

.. code-block:: haskell

    f x _ = x + 2		

NB. ``_`` est un *joker* qui évite de conserver la valeur associée
quand on en n'a pas besoin dans la partie droite.

Les évaluations suivantes seront immédiates car le second argument
ne sera jamais évalué : 
    
.. code-block:: haskell

    f 5 (29^35792)		
    f 5 (1/0)		

Paresse implique pureté
---------------------------
    
Un langage pur est un langage sans effet de bord.
Les effets de bord sont des effets de l'évaluation d'une expression sur l'extérieur. 
Or ces effets surviennent dans un ordre temporel qui a de l'importance
pour le bon fonctionnement du programme.

Par exemple : 

- le moment auquel on modifie une variable globale importe, car cela pourrait affecter l'évaluation d'autres expressions.
- le moment auquel on écrit à l'écran importe, car cela pourrait affecter l'ordre d'affichage des messages.  

La paresse, qui gomme l'ordre temporel des traitements, requière donc l'absence d'effet de bord. 

Défi 1 : tracer une évaluation
-------------------------------------

Soient les fonctions suivantes : 

.. literalinclude:: code/take-repeat.hs
   :language: haskell

Tracez (sur papier) l'évaluation de : 

.. code-block:: haskell

    take 3 (repeat 7)

Complexité
---------------------------

Soit la fonction suivante

.. literalinclude:: code/reverse1.hs
   :language: haskell

où

.. literalinclude:: code/concat.hs
   :language: haskell

Pour avoir une idée de la complexité
de ce code, nous allons tracer l'évaluation
de ``myReverse [1,2,3,4]``.  
	      
Trace 
---------------------------

.. code-block:: none

    myReverse [1,2,3,4] {second motif de myReverse}
    = myReverse [2,3,4] ++ [1]
    {le premier argument de (++) est évalué pour le matching}
    = (myReverse [3,4] ++ [2]) ++ [1] {même chose...}
    = ((myReverse [4] ++ [3]) ++ [2]) ++ [1]		
    = (((myReverse [] ++ [4]) ++ [3]) ++ [2]) ++ [1] {premier motif}		
    = ((([] ++ [4]) ++ [3]) ++ [2]) ++ [1] {premier motif de (++)}
    = (([4] ++ [3]) ++ [2]) ++ [1] {second motif de (++)}
    = ((4 : [] ++ [3]) ++ [2]) ++ [1] 
    {le second motif de (++) est immédiatement choisi,
    car (4 : [] ++ [3]) correspond clairement à (x:xs)}
    = (4 : ([] ++ [3]) ++ [2]) ++ [1] {même chose...}
    = 4 : (([] ++ [3]) ++ [2]) ++ [1] 
    {il reste à évaluer le second argument de (:) pour obtenir la liste,
    donc pour chaque élément on remonte la suite de concaténations...}

    
Défi 2 : complexité
----------------------------

Pour la version suivante, tracez (sur papier) l'évaluation de ``myReverse [1,2,3,4]``.
D'après vous, quelle est la complexité de cette version de ``myReverse`` ?

.. _reversecode:

.. literalinclude:: code/reverse2.hs
   :language: haskell


Conséquence 1 : structures de contrôle 
----------------------------------------

.. code-block:: haskell

    myBinaryAnd e1 e2 = case (e1, e2) of
		(False, _) -> False
		(True, x) -> x
		
.. code-block:: haskell

    myIf cond e1 e2 = case (cond, e1, e2) of
		       (True, e1, _) -> e1
		       (False, _, e2) -> e2

Grâce à la paresse, les deux appels suivants retournent immédiatement.  

.. code-block:: haskell

    myBinaryAnd False (head [] == 'x')
    myIf True 2 (34^9784346 > 34987345) 		



Conséquence 2 : structures de données infinies
-----------------------------------------------

.. literalinclude:: code/numsFrom.hs
   :language: haskell
		
.. code-block:: none

   *Main> numsFrom 1
   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,
   27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,
   50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,
   73,74,75,76,77,78,79,80,81Interrupted.

.. code-block:: none

   *Main> take 5 (numsFrom 1)
   [1,2,3,4,5]

   
Conséquence 3 : pipeline par composition
------------------------------------------

.. literalinclude:: code/pipelines.hs
   :language: haskell

Ce programme d'une ligne compte et affiche sur la sortie standard la taille des lignes lues sur l'entrée standard.
A ce stade, vous n'avez pas besoin de comprendre chaque fonction (cf. `Hoogle <https://www.haskell.org/hoogle/>`_
pour en savoir plus), seulement que l'opérateur ``.`` est l'opérateur
de composition : :math:`f \circ g` s'écrit ``f . g`` en Haskell. 

Bien que le programme ne soit qu'une suite de compositions, l'affichage commence avant que toutes les lignes soient lues.
En effet, grâce à l'évaluation paresseuse, dès qu'une ligne est lue, sa taille est aussitôt affichée. A essayer!

